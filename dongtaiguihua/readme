动态规划:

1、最简单的台阶问题：有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法？
由分析可知：n阶台阶，只可能是从n-1或是n-2的台阶上走上来的，台阶n的阶段依赖的是n-1和n-2的子阶段，
所以状态转移方程为dp[n] = dp[n-1] + dp[n-2]，属于最简单的动态规划问题


2、最短路径问题：给定一个矩阵m，从左上角开始每次只能向右走或者向下走，最后达到右下角的位置，
路径中所有数字累加起来就是路径和，返回所有路径的最小路径和，如果给定的m如下，那么路径1,3,1,
0,6,1,0就是最小路径和，返回12.
1 3 5 9
8 1 3 4
5 0 6 1
8 8 4 0
由分析可知：走到第(i ,j)个数时，只可能是从(i-1 ,j)或是(i ,j-1)走来的，路径(i ,j)的阶段依赖
的是(i-1 ,j)和(i ,j-1)的子阶段，所以状态转移方程为dp[i][j] =a[i][j] + min(dp[i-1][j]+ dp[i][j-1])，
属于简单的动态规划问题

3、动态规划+vector
题目描述
题目描述 

Redraiment是走梅花桩的高手。Redraiment总是起点不限，从前到后，往高的桩子走，但走的步数最多，不知道为什么？你能替Redraiment研究他最多走的步数吗？ 

样例输入
6
2 5 1 5 4 5
样例输出
3
提示
Example: 
6个点的高度各为 2 5 1 5 4 5 
如从第1格开始走,最多为3步, 2 4 5 
从第2格开始走,最多只有1步,5 
而从第3格开始走最多有3步,1 4 5 
从第5格开始走最多有2步,4 5

所以这个结果是3。



4、
最长递增子序列问题：给定数组arr，返回arr的最长递增子序列的长度，比如arr=[2,1,5,3,6,4,8,9,7]，最长递增子序列为[1,3,4,8,9]返回其长度为5.

5、
最长公共子序列问题：给定两个字符串str1和str2，返回两个字符串的最长公共子序列
例如：str1="1A2C3D4B56",str2="B1D23CA45B6A","123456"和"12C4B6"都是最长公共子序列，返回哪一个都行。
分析：本题是非常经典的动态规划问题，假设str1的长度为M，str2的长度为N，则生成M*N的二维数组dp，dp[i][j]的含义
是str1[0..i]与str2[0..j]的最长公共子序列的长度。
dp值的求法如下：dp[i][j]的值必然和dp[i-1][j],dp[i][j-1],dp[i-1][j-1]相关，结合下面的代码来看，我们实际上是
从第1行和第1列开始计算的，而把第0行和第0列都初始化为0，这是为了后面的取最大值在代码实现上的方便，dp[i][j]取三
者之间的最大值。


6、 
  线性模型
       线性模型的是动态规划中最常用的模型，上文讲到的最长单调子序列就是经典的线性模型，这里的线性指的是状态的排布是呈线性的。【例题6】是一个经典的面试题，我们将它作为线性模型的敲门砖。
      【例题6】在一个夜黑风高的晚上，有n（n <= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。
       每次过桥的时候最多两个人，如果桥这边还有人，那么还得回来一个人（送手电筒），也就是说N个人过桥的次数为2*N-3（倒推，当桥这边只剩两个人时只需要一次，三个人的情况为来回一次后加上两个人的情况...）。有一个人需要来回跑，将手电筒送回来（也许不是同一个人，realy？！）这个回来的时间是没办法省去的，并且回来的次数也是确定的，为N-2，如果是我，我会选择让跑的最快的人来干这件事情，但是我错了...如果总是跑得最快的人跑回来的话，那么他在每次别人过桥的时候一定得跟过去，于是就变成就是很简单的问题了，花费的总时间： 
      T = minPTime * (N-2) + (totalSum-minPTime)
      来看一组数据 四个人过桥花费的时间分别为 1 2 5 10，按照上面的公式答案是19，但是实际答案应该是17。
      具体步骤是这样的：
      第一步：1和2过去，花费时间2，然后1回来（花费时间1）；
      第二歩：3和4过去，花费时间10，然后2回来（花费时间2）；
      第三部：1和2过去，花费时间2，总耗时17。
      所以之前的贪心想法是不对的。
      我们先将所有人按花费时间递增进行排序，假设前i个人过河花费的最少时间为opt[i]，那么考虑前i-1个人过河的情况，即河这边还有1个人，河那边有i-1个人，并且这时候手电筒肯定在对岸，所以
      opt[i] = opt[i-1] + a[1] + a[i]        (让花费时间最少的人把手电筒送过来，然后和第i个人一起过河)
      如果河这边还有两个人，一个是第i号，另外一个无所谓，河那边有i-2个人，并且手电筒肯定在对岸，所以
      opt[i] = opt[i-2] + a[1] + a[i] + 2*a[2]    (让花费时间最少的人把电筒送过来，然后第i个人和另外一个人一起过河，由于花费时间最少的人在这边，所以下一次送手电筒过来的一定是花费次少的，送过来后花费最少的和花费次少的一起过河，解决问题)
      所以 opt[i] = min{opt[i-1] + a[1] + a[i] , opt[i-2] + a[1] + a[i] + 2*a[2] }
      
7、给定一个长度为n（n <= 1000）的字符串A，求插入最少多少个字符使得它变成一个回文串。

思路：

典型的动态规划区间模型，区间模型的状态表示一般为d[i][j]，表示区间[i, j]上的最优解，然后通过状态转移计算出[i+1, j]或者[i, j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解。


回文串拥有很明显的子结构特征，即当字符串X是一个回文串时，在X两边各添加一个字符‘a’后，aXa仍然是一个回文串，我们用d[i][j]来表示A[i…j]这个子串变成回文串所需要添加的最少的字符数，那么对于A[i] == A[j]的情况，很明显有 d[i][j] = d[i+1][j-1] （这里需要明确一点，当i+1 > j-1时也是有意义的，它代表的是空串，空串也是一个回文串，所以这种情况下d[i+1][j-1] = 0）；当A[i] != A[j]时，我们将它变成更小的子问题求解，我们有两种决策：

1、在A[j]后面添加一个字符A[i]；
2、在A[i]前面添加一个字符A[j]；

根据两种决策列出状态转移方程为：

d[i][j] = min{ d[i+1][j], d[i][j-1] } + 1;                (每次状态转移，区间长度增加1)

空间复杂度O(n^2)，时间复杂度O(n^2)，

思路2：
给定一个字符串，求插入最少的字符使得原字符串回文，求出该字符串逆序与正序的最长公共子序列长度，再用dp搞一下就行：



8、用dp法求最长对称子字符串长度


9、合唱队问题
计算最少出列多少位同学，使得剩下的同学排成合唱队形

说明：

N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。 
合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1，2…，K，他们的身高分别为T1，T2，…，TK，   则他们的身高满足存在i（1<=i<=K）使得T1<T2<......<Ti-1<Ti>Ti+1>......>TK。 
你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。 

链接：https://www.nowcoder.com/questionTerminal/6d9d69e3898f45169a441632b325c7b4
来源：牛客网

来说一下我的思路，两遍最长递增子序列，第一遍从左往右，第二遍从右往左，然后把两遍动态规划的结果相加，取最大的那个，比如8 186 186 150 200 160 130 197 200，第一遍dp的结果是 1 1 1 2 2 1 3 4，第二遍dp的结果为3 3 2 3 2 1 1 1，那么相加最大是5，所以需要出列的同学个数就是8-5+1=4.代码如下：
